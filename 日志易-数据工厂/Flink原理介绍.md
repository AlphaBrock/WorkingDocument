> 本文仅个人实践过程中积累知识点，可能存在某些知识点的误区

## 时间

> Flink实际计算场景，为了保证数据准确定，常用Event Time，因为该时间统计是和SPL统计方式最接近

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201214213056.png)

### Event Time

> SPL统计中的时间范围和FLink中的Event Time概念是最接近的

**事件时间**，事件(Event)本身的时间，即数据流中事件实际发生的时间，通常使用事件发生时的时间戳来描述，这些事件的时间戳通常在进入流处理应用之前就已经存在了，事件时间反映了事件真实的发生时间。所以，基于事件时间的计算操作，其结果是具有确定性的，无论数据流的处理速度如何、事件到达算子的顺序是否会乱，最终生成的结果都是一样的。

### Ingestion Time

**摄入时间**，事件进入Flink的时间，即将每一个事件在数据源算子的处理时间作为事件时间的时间戳，并自动生成水位线(watermarks,关于watermarks下文会详细分析)。

Ingestion Time从概念上讲介于Event Time和Processing Time之间。与Processing Time相比 ，它的性能消耗更多一些，但结果却更可预测。由于 Ingestion Time使用稳定的时间戳（在数据源处分配了一次），因此对记录的不同窗口操作将引用相同的时间戳，而在Processing Time中每个窗口算子都可以将记录分配给不同的窗口。

与Event Time相比，Ingestion Time无法处理任何乱序事件或迟到的数据，即无法提供确定的结果，但是程序不必指定如何生成水位线。在内部，Ingestion Time与Event Time非常相似，但是可以实现自动分配时间戳和自动生成水位线的功能。

### Processing Time

**处理时间**，根据处理机器的系统时钟决定数据流当前的时间，即事件被处理时当前系统的时间。还以窗口算子为例(关于window，下文会详细分析)，基于处理时间的窗口操作是以机器时间来进行触发的，由于数据到达窗口的速率不同，所以窗口算子中使用处理时间会导致不确定的结果。在使用处理时间时，无需等待水位线的到来后进行触发窗口，所以可以提供较低的延迟。

## 窗口

### 概念

对于Flink，如果来一条消息计算一条，这样是可以的，但是这样计算是非常频繁而且消耗资源，如果想做一些统计这是不可能的。所以对于Spark和Flink都产生了窗口计算。

比如 是因为我们想看到过去一分钟，过去半小时的访问数据，这时候我们就需要窗口。

**Window**：Window是处理无界流的关键，Windows将流拆分为一个个有限大小的`buckets`，可以在每一个`buckets`中进行计算。

**start_time,end_time**：当Window时时间窗口的时候，每个window都会有一个开始时间和结束时间（前开后闭），这个时间是系统时间。

### 生命周期

简而言之，只要属于此窗口的第一个元素到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定的允许延迟时，窗口将被完全删除。

例如:

```
使用基于事件时间的窗口策略，每5分钟创建一个不重叠（或翻滚）的窗口并允许延迟1分钟。
    
假定目前是12:00。

当具有落入该间隔的时间戳的第一个元素到达时，Flink将为12:00到12:05之间的间隔创建一个新窗口，当水位线（watermark）到12:06时间戳时将删除它。
```

### Keyed vs Non-Keyed Windows

> 划重点，后面实例有讲到

在定义窗口之前,要指定的第一件事是流是否需要Keyed，使用keyBy（...）将无界流分成逻辑的keyed stream。 如果未调用keyBy（...），则表示流不是keyed stream。

- 对于Keyed流，可以将传入事件的任何属性用作key。 拥有Keyed stream将允许窗口计算由多个任务并行执行，因为每个逻辑Keyed流可以独立于其余任务进行处理。 相同Key的所有元素将被发送到同一个任务。
- 在Non-Keyed流的情况下，原始流将不会被分成多个逻辑流，并且所有窗口逻辑将由单个任务执行，即并行性为1。

### 窗口分类

> 重点tumbling windows，当前flink计算kpi指标常用窗口类型

#### tumbling windows(翻滚窗口 无重叠)

翻滚窗口分配器将每个元素分配给固定窗口大小的窗口。滚动窗口大小固定的并且不重叠。

例如，如果指定大小为5分钟的滚动窗口，则将执行当前窗口，并且每五分钟将启动一个新窗口

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201214225350.svg)

#### sliding window(滚动窗口 有重叠)

滚动窗口分配器将每个元素分配给固定窗口大小的窗口。类似于滚动窗口分配器，窗口的大小由窗口大小参数配置。另外一个窗口滑动参数控制滑动窗口的启动频率(how frequently a sliding window is started)。因此，如果滑动大小小于窗口大小，滑动窗可以重叠。在这种情况下，元素被分配到多个窗口。

例如，你可以使用窗口大小为10分钟的窗口，滑动大小为5分钟。这样，每5分钟会生成一个窗口，包含最后10分钟内到达的事件。

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201214225419.svg)

#### session window(会话窗口 活动间隙)

会话窗口分配器通过活动会话分组元素。与滚动窗口和滑动窗口相比，会话窗口不会重叠，也没有固定的开始和结束时间。相反，当会话窗口在一段时间内没有接收到元素时会关闭。

例如，不活动的间隙时。会话窗口分配器配置会话间隙，定义所需的不活动时间长度(defines how long is the required period of inactivity)。当此时间段到期时，当前会话关闭，后续元素被分配到新的会话窗口。

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201214225621.svg)

## Watermarks(水位线)

> 本质上就是一个unix时间戳

### 作用

> 下面举一个抽象的例子

高考，是大家非常熟悉的场景。如果把高考的考试安排简单地看作是一个流处理应用，那么，每一个考试科目的开始时间到结束时间就是一个窗口，每个考生可以理解成一条记录，考生到达考场的时间可以理解成记录的时间戳，而考试可以理解成某种算子操作。

大家都知道，高考考试在开考后15分钟是不允许进场的，这个规定可以理解成一个水位线，比如，上午第一场语文考试，开考时间是9:30，允许在9:45之前进入考场，那么9:45这个时间可以理解成一个水位线。

在开考之前，有的同学喜欢提前到考场，有的同学喜欢卡点到考场。假设有个同学叫**考必胜**,ta是卡着时间点到的考场，但是早上由于吃了不干净的东西，突然感觉肚子不适，无奈之下在厕所里耽误了16分钟，那么按照规定，此时考必胜是不能够进入考场的，因为此时已经默认所有考生都已经在考场了，此时考试也已经触发，那么卡必胜就可以理解为迟到的事件。

------

watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用watermark机制结合window来实现。

我们知道，流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。

但是对于late element，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark。

### 乱序(out of order)

理想状态下，从kakfa消费出来的数据应该是这样的有序形式

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201215133804.svg)

但上面提到，在数据到达operator的过程中`不排除由于网络、主机时钟等原因，导致乱序`，那么实际的数据就是下面这样

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201215133754.svg)

### 迟到(allowedLateness)

allowedLateness是Flink window中用来容忍一段时间迟到数据的，对allowedLateness最容易的误解是它等同于将watermark减去或者说推迟一段时间，通过推迟窗口触发来容忍一定时间的迟到数据。事实上allowedLateness并不会推迟窗口的触发时间，它改变的是窗口的清除时间（cleanupTime）

也就是说allowedLateness改变的是窗口的清除时间，watermark触发窗口计算后窗口没有立马被清除而是等待allowedLateness后再清除，在这期间收到该窗口迟到数据时都会触发一次窗口计算。如下图，小圆表示窗口中的元素，watermark达到窗口endTime时会触发一次窗口计算，迟到的小圆还会分别触发一次窗口计算。

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201215140023.png)

虽说水位线表明着早于它的事件不应该再出现，但是接收到水位线以前的的消息是不可避免的，这就是所谓的迟到事件。实际上迟到事件是乱序事件的特例，和一般乱序事件不同的是它们的乱序程度超出了水位线的预计，导致窗口在它们到达之前已经关闭。

迟到事件出现时窗口已经关闭并产出了计算结果，因此处理的方法有3种：

- 重新激活已经关闭的窗口并重新计算以修正结果。
- 将迟到事件收集起来另外处理。
- 将迟到事件视为错误消息并丢弃。

Flink 默认的处理方式是第3种直接丢弃，其他两种方式分别使用`Side Output`和`Allowed Lateness`。

`Side Output`机制可以将迟到事件单独放入一个数据流分支，这会作为 window 计算结果的副产品，以便用户获取并对其进行特殊处理。

`Allowed Lateness`机制允许用户设置一个允许的最大迟到时长。Flink 会在窗口关闭后一直保存窗口的状态直至超过允许迟到时长，这期间的迟到事件不会被丢弃，而是默认会触发窗口重新计算。因为保存窗口状态需要额外内存，并且如果窗口计算使用了 `ProcessWindowFunction` API 还可能使得每个迟到事件触发一次窗口的全量计算，代价比较大，所以允许迟到时长不宜设得太长，迟到事件也不宜过多，否则应该考虑降低水位线提高的速度或者调整算法。

这里总结机制为：

- 窗口window 的作用是为了周期性的获取数据。
- watermark的作用是防止数据出现乱序(经常)，事件时间内获取不到指定的全部数据，而做的一种保险方法。
- allowLateNess是将窗口关闭时间再延迟一段时间。
- sideOutPut是最后兜底操作，所有过期延迟数据，指定窗口已经彻底关闭了，就会把数据放到侧输出流。

## 窗口计算触发机制

### 触发条件

上面谈到了对数据乱序问题的处理机制是watermark+window，那么window什么时候该被触发呢？

基于Event Time的事件处理，Flink默认的事件触发条件为：

**对于out-of-order及正常的数据而言**

- watermark的时间戳 > = window endTime
- 在 [window_start_time,window_end_time] 中有数据存在。

**对于late element太多的数据而言**

- Event Time > watermark的时间戳

WaterMark相当于一个EndLine，一旦Watermarks大于了某个window的end_time，就意味着windows_end_time时间和WaterMark时间相同的窗口开始计算执行了。

就是说，我们根据一定规则，计算出Watermarks，并且设置一些延迟，给迟到的数据一些机会，也就是说正常来讲，对于迟到的数据，我只等你一段时间，再不来就没有机会了。

WaterMark时间可以用Flink系统现实时间，也可以用处理数据所携带的Event time。

使用Flink系统现实时间，在并行和多线程中需要注意的问题较少，因为都是以现实时间为标准。

如果使用处理数据所携带的Event time作为WaterMark时间，需要注意两点：

- 因为数据到达并不是循序的，注意保存一个当前最大时间戳作为WaterMark时间
- 并行同步问题

### 实例

假如我们设置10s的时间窗口（window），那么0-10s，11-20s都是一个窗口，以0~10s为例，0为start-time，10为end-time。假如有4个数据的event-time分别是8(A),12.5(B),9(C),13.5(D)，我们设置Watermarks为当前所有到达数据event-time的最大值减去延迟值3.5秒

1. 当A到达的时候，Watermarks为`max{8}-3.5=8-3.5 = 4.5 < 10`,不会触发计算
2. 当B到达的时候，Watermarks为`max(12.5,8)-3.5=12.5-3.5 = 9 < 10`,不会触发计算
3. 当C到达的时候，Watermarks为`max(12.5,8,9)-3.5=12.5-3.5 = 9 < 10`,不会触发计算
4. 当D到达的时候，Watermarks为`max(13.5,12.5,8,9)-3.5=13.5-3.5 = 10 = 10`,触发计算
5. 触发计算的时候，会将A，C（因为他们都小于10）都计算进去，其中C是迟到的。

max这个很关键，就是当前窗口内，所有事件的最大事件。

这里的延迟3.5s是我们假设一个数据到达的时候，比他早3.5s的数据肯定也都到达了，这个是需要根据经验推算。假设加入D到达以后又到达了一个E，event-time=6，但是由于0~10的时间窗口已经开始计算了，所以E就丢了。

从这里上面E的丢失说明，水位线也不是万能的，但是如果根据我们自己的生产经验+侧道输出等方案，可以做到数据不丢失。

![](https://cdn.jsdelivr.net/gh/AlphaBrock/md_img/macos/20201215092750.gif)